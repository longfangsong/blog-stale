---
title: C++中的“黑魔法”-Traits
date: 2017-12-22 00:00:00
tags: [C++, 模版, 黑魔法]
mathjax: true
comments: true
summary: 在STL的实现中大量使用了一种平时可能并不常用的C++高级技巧：Traits，这里对其进行大致的介绍。
---
<h1 id="C-中的“黑魔法”-Traits"><a class="headerlink" href="#C-中的“黑魔法”-Traits" title="C++中的“黑魔法”-Traits"></a>C++中的“黑魔法”-Traits</h1><h2 id="何为Traits"><a class="headerlink" href="#何为Traits" title="何为Traits"></a>何为Traits</h2><blockquote>
<p><strong>Traits</strong>在面向对象程序设计中，是一个不可实例化（uninstantiable）的方法与类型的集合，为一个对象或算法提供了策略（policy）或实现自身接口的细节功能。</p>
<p>Traits作为模板类，既声明了统一的接口（包括类型、枚举、函数方法等），又可以通过模板特化，针对不同数据类型或其他模板参数，为类、函数或者通用算法在因为使用的数据类型不同而导致处理逻辑不同时，提供了区分不同类型的具体细节，从而把这部分用Traits实现的功能与其它共同的功能区分开来。例如，容器的元素的不同数据类型，或者<code>iostream</code>是使用<code>char</code>还是<code>wchar_t</code>。</p>
</blockquote>
<p>看着云里雾里，我们来结合实际例子进行理解。</p>
<h2 id="C-标准库实现中的Traits"><a class="headerlink" href="#C-标准库实现中的Traits" title="C++标准库实现中的Traits"></a>C++标准库实现中的Traits</h2><p>例如C++标准库里有这么一个函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIt</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br/><span class="line"><span class="class"><span class="title">void</span> <span class="title">advance</span>( <span class="title">InputIt</span>&amp; <span class="title">it</span>, <span class="title">Distance</span> <span class="title">n</span> );</span></span><br/></pre></td></tr></table></figure>
<p>作用是将迭代器<code>it</code>移动<code>n</code>个位置。</p>
<p>还有如下要求：</p>
<ul>
<li><blockquote>
<p>If <code>n</code> is negative, the iterator is decremented. In this case, <code>InputIt</code> must meet the requirements of     <code>BidirectionalIterator</code>, otherwise the behavior is undefined.</p>
</blockquote>
<p>如果<code>InputIt</code>是一个<code>BidirectionalIterator</code>，那么可以允许<code>n</code>为负数。</p>
</li>
<li><blockquote>
<p>if <code>InputIt</code> additionally meets the requirements of <code>RandomAccessIterator</code>, complexity is constant.</p>
</blockquote>
<p>如果<code>InputIt</code>是个<code>RandomAccessIterator</code>，那么需要这个函数在常数时间内完成任务。</p>
</li>
</ul>
<p>怎么实现？函数重载？各种<code>Iterator</code>可不是类型（想一想，为什么不把各种Iterator定义成类？）。RTTI？这是标准库，不能有性能损失，况且RTTI只能拿到typeid，也无法处理用户自定义的各种迭代器类型。</p>
<p>在这种情况下，Traits编程技法就有用武之地了。</p>
<p>我们首先来看看我们现在能做到什么：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br/><span class="line"><span class="class"><span class="title">void</span> <span class="title">advance_InputIterator</span>(<span class="title">InputIterator</span>&amp; <span class="title">it</span>, <span class="title">Distance</span> <span class="title">n</span>) {</span></span><br/><span class="line">	<span class="comment">// 实现省略，你应该很容易地就能补全它</span></span><br/><span class="line">}</span><br/><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">BidirectionalIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br/><span class="line"><span class="class"><span class="title">void</span> <span class="title">advance_BidirectionalIterator</span>(<span class="title">BidirectionalIterator</span>&amp; <span class="title">it</span>, <span class="title">Distance</span> <span class="title">n</span>) {</span></span><br/><span class="line">	<span class="comment">// 实现省略，你应该很容易地就能补全它</span></span><br/><span class="line">}</span><br/><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br/><span class="line"><span class="class"><span class="title">void</span> <span class="title">advance_RandomAccessIterator</span>(<span class="title">RandomAccessIterator</span>&amp; <span class="title">it</span>, <span class="title">Distance</span> <span class="title">n</span>) {</span></span><br/><span class="line">	<span class="comment">// 实现省略，你应该很容易地就能补全它</span></span><br/><span class="line">}</span><br/></pre></td></tr></table></figure>
<p>对于每种Iterator我们分别实现了不同的版本，然而我们需要的是这样一个统一的接口：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIt</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br/><span class="line"><span class="class"><span class="title">void</span> <span class="title">advance</span>( <span class="title">InputIt</span>&amp; <span class="title">it</span>, <span class="title">Distance</span> <span class="title">n</span> ) {</span></span><br/><span class="line">	<span class="comment">// 这部分是伪代码</span></span><br/><span class="line">    <span class="keyword">if</span> InputIt is RandomAccessIterator {</span><br/><span class="line">    	advance_RandomAccessIterator(it,n);</span><br/><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> InputIt is BidirectionalIterator {</span><br/><span class="line">        advance_BidirectionalIterator(it,n);</span><br/><span class="line">    } <span class="keyword">else</span> {</span><br/><span class="line">        advance_InputIterator(it,n);</span><br/><span class="line">    }</span><br/><span class="line">}</span><br/></pre></td></tr></table></figure>
<p>现在问题来了，怎么判断一个Iterator到底是什么类型（出于性能考虑，这个操作最好发生在编译期）？</p>
<p>你可能会想到为每种iterator定义一个tag类型，然后让迭代器实现时用typedef弄出自己的类型对应的tag，再利用模版特化来解决问题。</p>
<p>说实话想到这里已经不容易了，但是要注意原生指针是没有办法定义内部类型的，而原生指针应该是一种RandomAccessIterator，这该如何是好？</p>
<p>为了解决这个问题，STL想了一个好办法，即使用Traits：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/><span class="line">26</span><br/><span class="line">27</span><br/><span class="line">28</span><br/><span class="line">29</span><br/><span class="line">30</span><br/><span class="line">31</span><br/><span class="line">32</span><br/><span class="line">33</span><br/><span class="line">34</span><br/><span class="line">35</span><br/><span class="line">36</span><br/><span class="line">37</span><br/><span class="line">38</span><br/><span class="line">39</span><br/><span class="line">40</span><br/><span class="line">41</span><br/><span class="line">42</span><br/><span class="line">43</span><br/><span class="line">44</span><br/><span class="line">45</span><br/><span class="line">46</span><br/></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先，建立每种iterator的tag类型</span></span><br/><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span> {</span>};</span><br/><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span> {</span>};</span><br/><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator_tag</span> :</span> <span class="keyword">public</span> input_iterator_tag {};</span><br/><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bidirectional_iterator_tag</span> :</span> <span class="keyword">public</span> forward_iterator_tag {};</span><br/><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator_tag</span> :</span> <span class="keyword">public</span> bidirectional_iterator_tag {};</span><br/><span class="line"><span class="comment">// 然后将每种类型的对应实现略加修改，增加一个tag</span></span><br/><span class="line"><span class="comment">// 这样这三个函数就能构成重载了</span></span><br/><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br/><span class="line"><span class="class"><span class="title">void</span> __<span class="title">advance</span>(<span class="title">InputIterator</span>&amp; <span class="title">it</span>, <span class="title">Distance</span> <span class="title">n</span>, <span class="title">forward_iterator_tag</span>) {</span></span><br/><span class="line">	<span class="comment">// 实现和上面的完全一样</span></span><br/><span class="line">}</span><br/><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">BidirectionalIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br/><span class="line"><span class="class"><span class="title">void</span> __<span class="title">advance</span>(<span class="title">BidirectionalIterator</span>&amp; <span class="title">it</span>, <span class="title">Distance</span> <span class="title">n</span>, <span class="title">bidirectional_iterator_tag</span>) {</span></span><br/><span class="line">	<span class="comment">// 实现和上面的完全一样</span></span><br/><span class="line">}</span><br/><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br/><span class="line"><span class="class"><span class="title">void</span> __<span class="title">advance</span>(<span class="title">RandomAccessIterator</span>&amp; <span class="title">it</span>, <span class="title">Distance</span> <span class="title">n</span>, <span class="title">random_access_iterator_tag</span>) {</span></span><br/><span class="line">	<span class="comment">// 实现和上面的完全一样</span></span><br/><span class="line">}</span><br/><span class="line"></span><br/><span class="line"><span class="comment">// 注意！下面是iterator_traits部分</span></span><br/><span class="line"><span class="comment">// 最普通的iterator traits，Iterator应当是一个类，迭代器的信息由迭代器自己的实现给出</span></span><br/><span class="line"> <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator&gt;</span><br/><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span> {</span></span><br/><span class="line">    <span class="comment">// 无关部分略去</span></span><br/><span class="line">    <span class="comment">// 这里要求定义Iterator时typedef出iterator_category，即上面所给的5个tag之一</span></span><br/><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> Iterator::iterator_category iterator_category;</span><br/><span class="line">};</span><br/><span class="line"><span class="comment">// iterator traits针对原生指针的特化，原生指针没有::iterator_category</span></span><br/><span class="line"><span class="comment">// 但原生指针一定是random_access_iterator</span></span><br/><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br/><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;T *&gt; {</span></span><br/><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br/><span class="line">};</span><br/><span class="line"><span class="comment">// 同上</span></span><br/><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br/><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;const T *&gt; {</span></span><br/><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br/><span class="line">};</span><br/><span class="line"><span class="comment">// 对外接口</span></span><br/><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIt</span>, <span class="title">class</span> <span class="title">Distance</span>&gt;</span></span><br/><span class="line"><span class="class"><span class="title">void</span> <span class="title">advance</span>( <span class="title">InputIt</span>&amp; <span class="title">it</span>, <span class="title">Distance</span> <span class="title">n</span>) {</span></span><br/><span class="line">	<span class="comment">// 由iterator_traits取得iterator_category，并籍此决定要调用的__advance版本</span></span><br/><span class="line">	__advance(it,n,iterator_traits&lt;InputIt&gt;::iterator_category());</span><br/><span class="line">}</span><br/></pre></td></tr></table></figure>
<p>增加了iterator_traits这一层，并对原生指针进行了特化，完美地给出了解决方案！</p>
<p>思考：Traits编程技法有意无意地符合了设计模式中的一个重要原则，请问是哪个原则？</p>
<p>同样的技术也可以用来确定一个类型是否是原生类型等等。</p>
<p>C++11新增了<code>&lt;type_traits&gt;</code>这个头文件，用于方便我们识别类型，其中有各种识别类型用的struct（没错，是struct，不是function，这就是traits！），甚至可以部分代替C++缺少的反射。但由于牵扯到的知识较多，在此不作详细讲解。</p>
<h2 id="更多资源"><a class="headerlink" href="#更多资源" title="更多资源"></a>更多资源</h2><ul>
<li><p>维基百科上的<a href="https://zh.wikipedia.org/wiki/Traits_(计算机科学" rel="noopener" target="_blank">Traits</a>)</p>
</li>
<li><p>C++文档中的<a href="http://www.cplusplus.com/reference/type_traits/" rel="noopener" target="_blank">Type Traits</a></p>
</li>
<li><p>一个使用<code>&lt;type_traits&gt;</code>等手段进行编译期识别类型的例子:<a href="https://www.csdn.net/article/2015-12-03/2826381" rel="noopener" target="_blank">https://www.csdn.net/article/2015-12-03/2826381</a></p>
<p>​</p>
</li>
</ul>

