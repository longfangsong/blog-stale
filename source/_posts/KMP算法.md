---
title: KMP算法
date: 2018-04-10 00:00:00
tags: [算法, 字符串]
mathjax: true
comments: true
summary: KMP算法是字符串匹配算法中比较基本，而且也比较容易理解的一种，本文讲解了这种算法。
---
<h2 id="手动模拟匹配"><a class="headerlink" href="#手动模拟匹配" title="手动模拟匹配"></a>手动模拟匹配</h2><p>先看一个手动匹配的例子，感受一下。</p>
 hexo-inject:begin  hexo-inject:end <p>假设我们要从下面的字符串中：</p>
<p><img alt="StringToMatch" src="./StringToMatch.svg"/></p>
<p>匹配这样的字符串：</p>
<p><img alt="StringMatching" src="./StringMatching.svg"/></p>
<p>一开始，我们将两个字符串直接从头开始比较，直到发现第一个不匹配的字符：</p>
<p><img alt="NotMatch0" src="./NotMatch0.svg"/></p>
<p>这时如果使用的是暴力匹配的算法，那么就会将要匹配的字符串后移一个位置，直接进行比较，但是KMP算法则针对这一点进行了优化，由于前面三个字符已经成功匹配，而匹配失败的D字符在待匹配字符串中的真前缀（即<code>[C, BC]</code>）中并没有和已经成功匹配的部分（即<code>ABC</code>）的前缀相同的部分，故我们可以放心大胆地肯定，我们不可能在这里有任何成功的匹配，所以我们可以将待匹配字符串直接移到这里，开始匹配。</p>
<p><img alt="NotMatch1" src="./NotMatch1.svg"/></p>
<p>显然匹配不上。</p>
<p>继续后移匹配。</p>
<p><img alt="NotMatch2" src="./NotMatch2.svg"/></p>
<p>这里不匹配的<code>D</code>的真前缀<code>AB</code>和已经成功匹配的部分的前缀<code>AB</code>相同，所以我们可以直接将待匹配字符串移动到这里进行匹配<sup><a href="#fn_1" id="reffn_1">1</a></sup>：</p>
<p><img alt="NotMatch3" src="./NotMatch3.svg"/></p>
<p>配不上，后移：</p>
<p><img alt="NotMatch4" src="./NotMatch4.svg"/></p>
<p>继续后移：</p>
<p><img alt="Match" src="./Match.svg"/></p>
<p>成功匹配上了。</p>
<h2 id="分析"><a class="headerlink" href="#分析" title="分析"></a>分析</h2><p>从上面的模拟中我们可以发现，由于匹配过程中最多只会把源字符串扫描一遍，所以匹配的时间复杂度显然是O(n)。</p>
<p> 但是在匹配过程中，我们需要计算要匹配的字符串中某个字符的“真前缀”和整个要匹配的字符串的前缀的相同部分的长度，以此来决定匹配过程中的偏移量，由于这个值只和要匹配的字符串有关，故这可以事先算好，但我们该怎么算？</p>
<h2 id="偏移量算法"><a class="headerlink" href="#偏移量算法" title="偏移量算法"></a>偏移量算法</h2><p>这个偏移量的计算方法非常精妙，是KMP算法的核心。</p>
<p>我们仍然结合例子来理解。</p>
<p>我们来生成下面这个字符串的偏移量。</p>
<p><img alt="StringMatching2" src="./StringMatching2.svg"/></p>
<p>第0个偏移量当然为0。</p>
<p><img alt="next0" src="./next0.svg"/></p>
<p>然后我们将字符串和自身进行和上面的模拟匹配相似的匹配。</p>
<p><img alt="next1" src="./next1.svg"/></p>
<p>这里匹配不到，填0</p>
<p><img alt="next2" src="./next2.svg"/></p>
<p>这里匹配到了，填1</p>
<p><img alt="next3" src="./next3.svg"/></p>
<p>接着往后匹配，直到匹配不成功为止，每次填入的数字加一</p>
<p><img alt="next4" src="./next4.svg"/></p>
<p>匹配不成功的点出现后，直接将字符串的头移动到这个不匹配点，重新开始匹配</p>
<p><img alt="next5" src="./next5.svg"/></p>
<p>最后能得到这样的偏移量表</p>
<p><img alt="next6" src="./next6.svg"/></p>
<p>很多时候为了编程方便，我们会将偏移量表后移一位，并丢弃最后一位，像这样：</p>
<p><img alt="next7" src="./next7.svg"/></p>
<p>第0位填-1是习惯，其实没多大意义，像我一直填0的，啥问题都没有。</p>
<h2 id="参考代码实现"><a class="headerlink" href="#参考代码实现" title="参考代码实现"></a>参考代码实现</h2><p>纯C语言实现，使用其他语言时你不应当写此。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/><span class="line">26</span><br/><span class="line">27</span><br/><span class="line">28</span><br/><span class="line">29</span><br/><span class="line">30</span><br/><span class="line">31</span><br/><span class="line">32</span><br/><span class="line">33</span><br/><span class="line">34</span><br/><span class="line">35</span><br/><span class="line">36</span><br/><span class="line">37</span><br/><span class="line">38</span><br/><span class="line">39</span><br/><span class="line">40</span><br/><span class="line">41</span><br/><span class="line">42</span><br/><span class="line">43</span><br/><span class="line">44</span><br/><span class="line">45</span><br/><span class="line">46</span><br/><span class="line">47</span><br/><span class="line">48</span><br/><span class="line">49</span><br/><span class="line">50</span><br/><span class="line">51</span><br/><span class="line">52</span><br/><span class="line">53</span><br/><span class="line">54</span><br/><span class="line">55</span><br/><span class="line">56</span><br/><span class="line">57</span><br/><span class="line">58</span><br/><span class="line">59</span><br/><span class="line">60</span><br/><span class="line">61</span><br/><span class="line">62</span><br/><span class="line">63</span><br/><span class="line">64</span><br/><span class="line">65</span><br/><span class="line">66</span><br/></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br/><span class="line"><span class="comment"> * 在 @arg result 处生成 @arg needle 的KMP表</span></span><br/><span class="line"><span class="comment"> * @param needle 要匹配的字符串</span></span><br/><span class="line"><span class="comment"> * @param result 生成的KMP表存放的位置</span></span><br/><span class="line"><span class="comment"> */</span></span><br/><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmp_create_table</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *needle, <span class="keyword">size_t</span> *result)</span> </span>{</span><br/><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> length = <span class="built_in">strlen</span>(needle);</span><br/><span class="line">    <span class="keyword">if</span> (length != <span class="number">0</span>) {</span><br/><span class="line">        result[<span class="number">0</span>] = <span class="number">0</span>;</span><br/><span class="line">        result[<span class="number">1</span>] = <span class="number">0</span>;</span><br/><span class="line">        <span class="keyword">size_t</span> current_count = <span class="number">0</span>;</span><br/><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span> *src = needle + <span class="number">1</span>, *dst = needle;</span><br/><span class="line">             src - needle &lt; length - <span class="number">1</span>;</span><br/><span class="line">             ++src) {</span><br/><span class="line">            <span class="keyword">if</span> (*src != *dst) {</span><br/><span class="line">                current_count = <span class="number">0</span>;</span><br/><span class="line">                result[src - needle + <span class="number">1</span>] = <span class="number">0</span>;</span><br/><span class="line">                dst = needle;</span><br/><span class="line">            } <span class="keyword">else</span> {</span><br/><span class="line">                ++current_count;</span><br/><span class="line">                result[src - needle + <span class="number">1</span>] = current_count;</span><br/><span class="line">                ++dst;</span><br/><span class="line">            }</span><br/><span class="line">        }</span><br/><span class="line">    }</span><br/><span class="line">}</span><br/><span class="line"></span><br/><span class="line"><span class="comment">/**</span></span><br/><span class="line"><span class="comment"> * 用KMP匹配字符串</span></span><br/><span class="line"><span class="comment"> * @param haystack 源串</span></span><br/><span class="line"><span class="comment"> * @param needle 待匹配的串</span></span><br/><span class="line"><span class="comment"> * @param kmp_table KMP表，传入NULL则会自动生成</span></span><br/><span class="line"><span class="comment"> * @return @arg needle在 @arg haystack中的位置，如果不存在，则返回 (size_t)-1</span></span><br/><span class="line"><span class="comment"> */</span></span><br/><span class="line"><span class="keyword">size_t</span> kmp_match(<span class="keyword">const</span> <span class="keyword">char</span> *haystack, <span class="keyword">const</span> <span class="keyword">char</span> *needle, <span class="keyword">const</span> <span class="keyword">size_t</span> *kmp_table) {</span><br/><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> *table = kmp_table;</span><br/><span class="line">    <span class="keyword">size_t</span> length_of_needle = <span class="built_in">strlen</span>(needle);</span><br/><span class="line">    <span class="keyword">size_t</span> length_of_haystack = <span class="built_in">strlen</span>(haystack);</span><br/><span class="line">    <span class="keyword">if</span> (kmp_table == <span class="literal">NULL</span>) {</span><br/><span class="line">        table = <span class="built_in">malloc</span>(length_of_needle);</span><br/><span class="line">        kmp_create_table(needle, (<span class="keyword">size_t</span> *) table);</span><br/><span class="line">    }</span><br/><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *src = haystack, *dst = needle;</span><br/><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) {</span><br/><span class="line">        <span class="keyword">if</span> (*src == *dst) {</span><br/><span class="line">            ++src;</span><br/><span class="line">            ++dst;</span><br/><span class="line">            <span class="keyword">if</span> (dst - needle == length_of_needle) {</span><br/><span class="line">                <span class="keyword">return</span> src - haystack - length_of_needle;</span><br/><span class="line">            }</span><br/><span class="line">        } <span class="keyword">else</span> {</span><br/><span class="line">            <span class="keyword">if</span> (dst == needle) {</span><br/><span class="line">                ++src;</span><br/><span class="line">            } <span class="keyword">else</span> {</span><br/><span class="line">                dst = needle + table[dst - needle];</span><br/><span class="line">            }</span><br/><span class="line">            <span class="keyword">if</span> (src - haystack &gt; length_of_haystack - length_of_needle) {</span><br/><span class="line">                <span class="keyword">break</span>;</span><br/><span class="line">            }</span><br/><span class="line">        }</span><br/><span class="line">    }</span><br/><span class="line">    <span class="keyword">if</span> (kmp_table == <span class="literal">NULL</span>) {</span><br/><span class="line">        <span class="built_in">free</span>((<span class="keyword">void</span> *) table);</span><br/><span class="line">    }</span><br/><span class="line">    <span class="keyword">return</span> (<span class="keyword">size_t</span>) <span class="number">-1</span>;</span><br/><span class="line">}</span><br/></pre></td></tr></table></figure>
<h2 id="改进"><a class="headerlink" href="#改进" title="改进"></a>改进</h2><p>生成KMP表的方式还可以改进：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/><span class="line">26</span><br/><span class="line">27</span><br/><span class="line">28</span><br/><span class="line">29</span><br/><span class="line">30</span><br/></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br/><span class="line"><span class="comment"> * 在 @arg result 处生成 @arg needle 的KMP表</span></span><br/><span class="line"><span class="comment"> * @param needle 要匹配的字符串</span></span><br/><span class="line"><span class="comment"> * @param result 生成的KMP表存放的位置</span></span><br/><span class="line"><span class="comment"> */</span></span><br/><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmp_create_table</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *needle, <span class="keyword">size_t</span> *result)</span> </span>{</span><br/><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> length = <span class="built_in">strlen</span>(needle);</span><br/><span class="line">    <span class="keyword">if</span> (length != <span class="number">0</span>) {</span><br/><span class="line">        result[<span class="number">0</span>] = <span class="number">0</span>;</span><br/><span class="line">        result[<span class="number">1</span>] = <span class="number">0</span>;</span><br/><span class="line">        <span class="keyword">size_t</span> current_count = <span class="number">0</span>;</span><br/><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span> *src = needle + <span class="number">1</span>, *dst = needle;</span><br/><span class="line">             src - needle &lt; length - <span class="number">1</span>;</span><br/><span class="line">             ++src) {</span><br/><span class="line">            <span class="keyword">if</span> (*src != *dst) {</span><br/><span class="line">                current_count = <span class="number">0</span>;</span><br/><span class="line">                result[src - needle + <span class="number">1</span>] = <span class="number">0</span>;</span><br/><span class="line">                dst = needle;</span><br/><span class="line">            } <span class="keyword">else</span> {</span><br/><span class="line">                ++current_count;</span><br/><span class="line">                <span class="keyword">if</span> (needle[src - needle + <span class="number">1</span>] == *(dst + <span class="number">1</span>)) {</span><br/><span class="line">                    result[src - needle + <span class="number">1</span>] = result[current_count];</span><br/><span class="line">                } <span class="keyword">else</span> {</span><br/><span class="line">                    result[src - needle + <span class="number">1</span>] = current_count;</span><br/><span class="line">                }</span><br/><span class="line">                ++dst;</span><br/><span class="line">            }</span><br/><span class="line">        }</span><br/><span class="line">    }</span><br/><span class="line">}</span><br/></pre></td></tr></table></figure>
<blockquote id="fn_1">
<sup>1</sup>. 其实这里计算真前缀时可以将<code>D</code>本身带上，这样就能后移更多距离，但是Wikipedia上给的例子并没有考虑这一点，而且实现起来也不方便，故我也不考虑了。<a href="#reffn_1" title="Jump back to footnote [1] in the text."> ↩</a>
</blockquote>

