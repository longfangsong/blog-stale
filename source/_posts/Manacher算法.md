---
title: Manacher算法
date: 2018-11-25 00:00:00
tags: [算法]
mathjax: true
comments: true
summary: Manacher算法是用于在线性时间内寻找一个字符串中最长的回文子串的算法。
---
<p>前段时间刷<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/description/" rel="noopener" target="_blank">Leetcode 5</a>。找回文子串这个事情，比较容易想到的算法是确定一个中心点，然后向两侧扩展的中心扩展算法，这个算法实现起来简单方便，时间复杂度是$O(n^2)$，和$O(n^3)$的枚举所有子串比起来不算太坏，但是这个算法没有充分利用前面计算出的回文信息来辅助后面的计算，从这里可以看出也许还有优化的空间。</p>
<p>然而我自己可想不到怎么优化，于是看<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/" rel="noopener" target="_blank">Leetcode上的解答</a>，发现了 Manacher 这个神奇的玩意，看了一下感觉挺妙<sup><a href="#fn_0" id="reffn_0">0</a></sup>的。</p>
<h3 id="预处理"><a class="headerlink" href="#预处理" title="预处理"></a>预处理</h3><p>为了处理方便，我们首先将原来的字符串头尾和每两个字符中间都加上一个分隔符（设为<code>#</code>），如：</p>
<p>原串：</p>
<p><img alt="origin" src="./origin.svg"/></p>
<p>预处理过后：</p>
<p><img alt="expanded" src="./expanded.svg"/></p>
<p>这样一来，原本形如<code>abba</code>的偶数长回文字符串会变成<code>#a#b#b#a#</code>的奇数长回文字符串，在进行计算时不再需要分开处理。</p>
<p>同时，第i个位置上的字符被映射到了新字符串的$2 \times i+1$个位置，或者说新字符串的第j个位置上的字符是原字符串的第$i/2$<sup><a href="#fn_1" id="reffn_1">1</a></sup>个位置上的字符。</p>
<h3 id="回文半径表"><a class="headerlink" href="#回文半径表" title="回文半径表"></a>回文半径表</h3><h4 id="回文半径2"><a class="headerlink" href="#回文半径2" title="回文半径2"></a>回文半径<sup><a href="#fn_2" id="reffn_2">2</a></sup></h4><p>所谓回文半径，指的就是以某个字符为中心的最长回文字符串的结尾到这个字符的距离，同时由于回文数的定义，也等于这个字符串的头到这个字符的距离，例如上例中的<img alt="c15" src="./c15.svg"/>，以其为中心的最长回文字符串为：<img alt="c-mid-pali" src="./c-mid-pali.svg"/>，所以其回文半径就是$20-15=15-10=5$。</p>
<p>显然回文半径最长的一个元素也是最长的回文字符串的中间元素，也就是说我们只要找到了这个回文半径最长的元素就找到了最长的回文字符串。</p>
<h4 id="回文半径表-1"><a class="headerlink" href="#回文半径表-1" title="回文半径表"></a>回文半径表</h4><p>就是把所有字符对应的回文半径填进表里：</p>
<p><img alt="radius-table" src="./radius-table.svg"/></p>
<p>打出了这张表就能很方便地知道最长子字符串的长度和位置了。</p>
<p>那么怎么打这张表呢？</p>
<p>显然不能用和中心扩展算法相似的方法去打，那样对时间复杂度毫无助益，而是要尽可能使用前面的数据推后面的数据。</p>
<p>我们来看几个情况：</p>
<h5 id="情况1"><a class="headerlink" href="#情况1" title="情况1"></a>情况1</h5><p><img alt="situation-1" src="./situation-1.svg"/></p>
<p>例如这个回文半径表第0-12个元素已经计算好了，我们要计算第13个元素，这里称为i。</p>
<p>之前得到的可以覆盖到整个字符串最右边的回文字符串中心位置是第11个元素，这里称为mid。</p>
<p>此时要找到i关于mid的对称位置，这里就是第9个元素，称为j。</p>
<p><img alt="variables-1" src="./variables-1.svg"/></p>
<p>显然这里的i可以看作是j以mid为中心翻转过来的，而以j为中心的回文字符串也可以以mid为中心翻转成以i为中心的回文字符串，如下：</p>
<p><img alt="rotate-1" src="./rotate-1.svg"/></p>
<p>所以i处的值应该是和j一样的：</p>
<p><img alt="situation-1-result" src="./situation-1-result.svg"/></p>
<h5 id="情况2"><a class="headerlink" href="#情况2" title="情况2"></a>情况2</h5><p>然而按照上面的方法，这里会出问题：</p>
<p><img alt="situation-2" src="./situation-2.svg"/></p>
<p>因为此时以j为中心的回文字符串在翻转之后（注意这里的图为了清晰起见只画了以j为中心的回文字符串的左半边，右半边画了会重叠起来我就没画）：</p>
<p><img alt="rotate-2" src="./rotate-2.svg"/></p>
<p>其中21和22位置上的元素已经不在以mid为中心的回文串内部了，所以我们并不能保证21和22号元素一定和1号和2号元素相等（实际上在这个例子中它们确实并不相等），在这种情况下，我们只能保证以i为中心，到<strong>以mid为中心的回文串的结尾</strong><sup><a href="#fn_3" id="reffn_3">3</a></sup>为止的串一定的是回文的。对于后面的元素，我们只能直接暴力地进行匹配（即21和9匹配，22和8匹配）。</p>
<h5 id="情况3"><a class="headerlink" href="#情况3" title="情况3"></a>情况3</h5><p>当我们要计算第21个元素：</p>
<p><img alt="situation-3" src="./situation-3.svg"/></p>
<p>这时i已经完全在mid为中心的回文串外，也就是说我们目前没有任何和i为中心的回文串有关的已知信息，此时只能暴力地进行匹配了。</p>
<h5 id="总结"><a class="headerlink" href="#总结" title="总结"></a>总结</h5><p>总的来说，生成这张表的算法是：</p>
<p>对每串中的元素个i：</p>
<ul>
<li><p>若i在已知<strong>覆盖的最右</strong>的回文串右边，则暴力匹配</p>
</li>
<li><p>若i在已知<strong>覆盖的最右</strong>的回文串中</p>
<p>找出i关于mid的对称元素j</p>
<ul>
<li><p>若<strong>j的回文半径</strong>大于<strong>mid为中心的回文串的左侧到j的距离</strong></p>
<p>从mid为中心的回文串的右侧开始暴力匹配</p>
</li>
<li><p>否则</p>
<p>回文半径表中i对应的值就和j对应的值一样</p>
</li>
</ul>
</li>
</ul>
<h2 id="代码实现"><a class="headerlink" href="#代码实现" title="代码实现"></a>代码实现</h2><p>那么我们就能得到如下代码：</p>
<p>首先是预处理：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">padding</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> {</span><br/><span class="line">	<span class="keyword">var</span> result bytes.Buffer</span><br/><span class="line">	<span class="keyword">for</span> _, ch := <span class="keyword">range</span> s {</span><br/><span class="line">		result.WriteRune(<span class="string">'#'</span>)</span><br/><span class="line">		result.WriteRune(ch)</span><br/><span class="line">	}</span><br/><span class="line">	result.WriteRune(<span class="string">'#'</span>)</span><br/><span class="line">	<span class="keyword">return</span> result.String()</span><br/><span class="line">}</span><br/></pre></td></tr></table></figure>
<p>然后是打表：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/><span class="line">26</span><br/><span class="line">27</span><br/><span class="line">28</span><br/><span class="line">29</span><br/><span class="line">30</span><br/><span class="line">31</span><br/><span class="line">32</span><br/><span class="line">33</span><br/><span class="line">34</span><br/><span class="line">35</span><br/><span class="line">36</span><br/><span class="line">37</span><br/><span class="line">38</span><br/><span class="line">39</span><br/><span class="line">40</span><br/><span class="line">41</span><br/><span class="line">42</span><br/><span class="line">43</span><br/><span class="line">44</span><br/><span class="line">45</span><br/><span class="line">46</span><br/><span class="line">47</span><br/><span class="line">48</span><br/><span class="line">49</span><br/><span class="line">50</span><br/><span class="line">51</span><br/><span class="line">52</span><br/><span class="line">53</span><br/><span class="line">54</span><br/></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">palindromeRadiusTable</span><span class="params">(s <span class="keyword">string</span>)</span> []<span class="title">int</span></span> {</span><br/><span class="line">	padded := padding(s)</span><br/><span class="line">	table := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(padded))</span><br/><span class="line">	rightMostIndexLeft := <span class="number">-1</span></span><br/><span class="line">	rightMostIndexRight := <span class="number">-1</span></span><br/><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> padded {</span><br/><span class="line">		<span class="keyword">if</span> i &gt; rightMostIndexRight {</span><br/><span class="line">            <span class="comment">// 无信息，暴力匹配</span></span><br/><span class="line">			table[i] = <span class="number">1</span></span><br/><span class="line">			left := i - <span class="number">1</span></span><br/><span class="line">			right := i + <span class="number">1</span></span><br/><span class="line">			<span class="keyword">for</span> left &gt;= <span class="number">0</span> &amp;&amp; right &lt; <span class="built_in">len</span>(padded) {</span><br/><span class="line">				<span class="keyword">if</span> padded[left] == padded[right] {</span><br/><span class="line">					rightMostIndexLeft = left</span><br/><span class="line">					rightMostIndexRight = right</span><br/><span class="line">					table[i]++</span><br/><span class="line">					left--</span><br/><span class="line">					right++</span><br/><span class="line">				} <span class="keyword">else</span> {</span><br/><span class="line">					<span class="keyword">break</span></span><br/><span class="line">				}</span><br/><span class="line">			}</span><br/><span class="line">		} <span class="keyword">else</span> {</span><br/><span class="line">			mid := (rightMostIndexLeft + rightMostIndexRight) / <span class="number">2</span></span><br/><span class="line">			j := mid*<span class="number">2</span> - i</span><br/><span class="line">			<span class="keyword">if</span> table[j] &gt;= j-rightMostIndexLeft+<span class="number">1</span> {</span><br/><span class="line">                <span class="comment">// j的回文半径大于mid为中心的回文串的左侧到j的距离</span></span><br/><span class="line">                <span class="comment">// 即以j为中心的回文串不全在以mid为中心的回文串内</span></span><br/><span class="line">                <span class="comment">// 先储存已经在mid内的部分的长度</span></span><br/><span class="line">				table[i] = j - rightMostIndexLeft + <span class="number">1</span></span><br/><span class="line">                <span class="comment">// 剩余部分暴力匹配</span></span><br/><span class="line">				left := i - table[i]</span><br/><span class="line">				right := i + table[i]</span><br/><span class="line">				<span class="keyword">for</span> left &gt;= <span class="number">0</span> &amp;&amp; right &lt; <span class="built_in">len</span>(padded) {</span><br/><span class="line">					<span class="keyword">if</span> padded[left] == padded[right] {</span><br/><span class="line">						<span class="keyword">if</span> right &gt; rightMostIndexRight {</span><br/><span class="line">							rightMostIndexLeft = left</span><br/><span class="line">							rightMostIndexRight = right</span><br/><span class="line">						}</span><br/><span class="line">						table[i]++</span><br/><span class="line">						left--</span><br/><span class="line">						right++</span><br/><span class="line">					} <span class="keyword">else</span> {</span><br/><span class="line">						<span class="keyword">break</span></span><br/><span class="line">					}</span><br/><span class="line">				}</span><br/><span class="line">			} <span class="keyword">else</span> {</span><br/><span class="line">                <span class="comment">// 以j为中心的回文串全在以mid为中心的回文串内</span></span><br/><span class="line">				table[i] = table[j]</span><br/><span class="line">			}</span><br/><span class="line">		}</span><br/><span class="line">	}</span><br/><span class="line">	<span class="keyword">return</span> table</span><br/><span class="line">}</span><br/></pre></td></tr></table></figure>
<p>稍加修改，就能得到最长回文子串的求法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/><span class="line">26</span><br/><span class="line">27</span><br/><span class="line">28</span><br/><span class="line">29</span><br/><span class="line">30</span><br/><span class="line">31</span><br/><span class="line">32</span><br/><span class="line">33</span><br/><span class="line">34</span><br/><span class="line">35</span><br/><span class="line">36</span><br/><span class="line">37</span><br/><span class="line">38</span><br/><span class="line">39</span><br/><span class="line">40</span><br/><span class="line">41</span><br/><span class="line">42</span><br/><span class="line">43</span><br/><span class="line">44</span><br/><span class="line">45</span><br/><span class="line">46</span><br/><span class="line">47</span><br/><span class="line">48</span><br/><span class="line">49</span><br/><span class="line">50</span><br/><span class="line">51</span><br/><span class="line">52</span><br/><span class="line">53</span><br/><span class="line">54</span><br/></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> {</span><br/><span class="line">	padded := padding(s)</span><br/><span class="line">	table := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(padded))</span><br/><span class="line">	rightMostIndexLeft := <span class="number">-1</span></span><br/><span class="line">	rightMostIndexRight := <span class="number">-1</span></span><br/><span class="line">	maxLength := <span class="number">0</span></span><br/><span class="line">	maxI := <span class="number">-1</span></span><br/><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> padded {</span><br/><span class="line">		<span class="keyword">if</span> i &gt; rightMostIndexRight {</span><br/><span class="line">			table[i] = <span class="number">1</span></span><br/><span class="line">			left := i - <span class="number">1</span></span><br/><span class="line">			right := i + <span class="number">1</span></span><br/><span class="line">			<span class="keyword">for</span> left &gt;= <span class="number">0</span> &amp;&amp; right &lt; <span class="built_in">len</span>(padded) {</span><br/><span class="line">				<span class="keyword">if</span> padded[left] == padded[right] {</span><br/><span class="line">					rightMostIndexLeft = left</span><br/><span class="line">					rightMostIndexRight = right</span><br/><span class="line">					table[i]++</span><br/><span class="line">					left--</span><br/><span class="line">					right++</span><br/><span class="line">				} <span class="keyword">else</span> {</span><br/><span class="line">					<span class="keyword">break</span></span><br/><span class="line">				}</span><br/><span class="line">			}</span><br/><span class="line">		} <span class="keyword">else</span> {</span><br/><span class="line">			mid := (rightMostIndexLeft + rightMostIndexRight) / <span class="number">2</span></span><br/><span class="line">			j := mid*<span class="number">2</span> - i</span><br/><span class="line">			<span class="keyword">if</span> table[j] &gt;= j-rightMostIndexLeft+<span class="number">1</span> {</span><br/><span class="line">				table[i] = j - rightMostIndexLeft + <span class="number">1</span></span><br/><span class="line">				left := i - table[i]</span><br/><span class="line">				right := i + table[i]</span><br/><span class="line">				<span class="keyword">for</span> left &gt;= <span class="number">0</span> &amp;&amp; right &lt; <span class="built_in">len</span>(padded) {</span><br/><span class="line">					<span class="keyword">if</span> padded[left] == padded[right] {</span><br/><span class="line">						<span class="keyword">if</span> right &gt; rightMostIndexRight {</span><br/><span class="line">							rightMostIndexLeft = left</span><br/><span class="line">							rightMostIndexRight = right</span><br/><span class="line">						}</span><br/><span class="line">						table[i]++</span><br/><span class="line">						left--</span><br/><span class="line">						right++</span><br/><span class="line">					} <span class="keyword">else</span> {</span><br/><span class="line">						<span class="keyword">break</span></span><br/><span class="line">					}</span><br/><span class="line">				}</span><br/><span class="line">			} <span class="keyword">else</span> {</span><br/><span class="line">				table[i] = table[j]</span><br/><span class="line">			}</span><br/><span class="line">		}</span><br/><span class="line">		<span class="keyword">if</span> table[i] &gt; maxLength {</span><br/><span class="line">			maxLength = table[i]</span><br/><span class="line">			maxI = i</span><br/><span class="line">		}</span><br/><span class="line">	}</span><br/><span class="line">	<span class="keyword">return</span> s[(maxI-maxLength+<span class="number">1</span>)/<span class="number">2</span> : (maxI+maxLength)/<span class="number">2</span>]</span><br/><span class="line">}</span><br/></pre></td></tr></table></figure>
<h2 id="凭什么它是O-n"><a class="headerlink" href="#凭什么它是O-n" title="凭什么它是O(n)"></a>凭什么它是O(n)</h2><p>我们看这个<code>rightMostIndexRight</code>变量，看代码就知道了，设数组长度为n，则：</p>
<ul>
<li><code>rightMostIndexRight</code>从来没有减少过，一直在增加</li>
<li>每次匹配成功，<code>rightMostIndexRight</code>都将增加1</li>
<li><code>rightMostIndexRight</code>不会超过n</li>
</ul>
<p>所以实际执行匹配的次数不会超过n，即算法是O(n)的。</p>
<blockquote id="fn_0">
<sup>0</sup>. 真实想法：wcnm这怎么想到的，Manacher NB！<a href="#reffn_0" title="Jump back to footnote [0] in the text."> ↩</a>
</blockquote>
<blockquote id="fn_1">
<sup>1</sup>. 这里的除号是指类C语言整数除法<a href="#reffn_1" title="Jump back to footnote [1] in the text."> ↩</a>
</blockquote>
<blockquote id="fn_2">
<sup>2</sup>. <a href="https://articles.leetcode.com/longest-palindromic-substring-part-ii/" rel="noopener" target="_blank">leetcode上的讲解</a>中，回文半径是不包含中心字符本身的，这样定义的回文半径会比这里讲的小1<a href="#reffn_2" title="Jump back to footnote [2] in the text."> ↩</a>
</blockquote>
<blockquote id="fn_3">
<sup>3</sup>. 这里的粗体是为了把词句分开来……自然语言的括号意思和我想要的不同……总之能看就行<a href="#reffn_3" title="Jump back to footnote [3] in the text."> ↩</a>
</blockquote>

