---
title: 数组
date: 2017-10-10 00:00:00
tags: [C, 汇编]
mathjax: true
comments: true
summary: 从汇编的角度看C语言的数组
---
<h1 id="数组"><a class="headerlink" href="#数组" title="数组"></a>数组</h1><p>今天上课说了VLA（变量大小的数组），让我想起我的师傅曾经告诉过我，VLA是C++兼容C时的一个大坑。</p>
 hexo-inject:begin  hexo-inject:end <p>sj老师说使用VLA会造成内存泄漏，我：……</p>
<p>分配在栈上的东西关内存泄漏什么事啊……</p>
<p>算了，我们从一般的固定大小数组说起，当然，from the perspective of asm。</p>
<h2 id="固定大小的数组"><a class="headerlink" href="#固定大小的数组" title="固定大小的数组"></a>固定大小的数组</h2><h3 id="数组的声明"><a class="headerlink" href="#数组的声明" title="数组的声明"></a>数组的声明</h3><p>汇编这一段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br/><span class="line">        <span class="keyword">int</span> arr[<span class="number">10</span>];</span><br/><span class="line">        ++arr[<span class="number">0</span>];</span><br/><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br/><span class="line">}</span><br/></pre></td></tr></table></figure>
<p>得到（无关代码已忽略）：</p>
rbp是当前栈帧的栈底，rsp是当前栈帧的栈顶。
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/></pre></td><td class="code"><pre><span class="line">subq    <span class="number">$48</span>, %rsp		<span class="comment">; 在栈上为main函数留好空间（栈帧），</span></span><br/><span class="line">						<span class="comment">; 空开40个字节给数组，8个给%fs:40的值</span></span><br/><span class="line"><span class="keyword">movq</span>    %fs:<span class="number">40</span>, %rax	<span class="comment">; 我也不知道%fs:40是啥……</span></span><br/><span class="line">						<span class="comment">; 40这个值和数组的大小没关系，换几个数组大小测也是40</span></span><br/><span class="line">						<span class="comment">; 不过这不重要</span></span><br/><span class="line"><span class="keyword">movq</span>    %rax, -<span class="number">8</span>(%rbp)  <span class="comment">; 把%fs:40的值放在堆栈底部，这还是不重要</span></span><br/><span class="line">xorl    %eax, %eax 		<span class="comment">; 即EAX=0，不过这还是不重要</span></span><br/><span class="line">movl    -<span class="number">48</span>(%rbp), %eax <span class="comment">; 取数组第0个数据</span></span><br/><span class="line">addl    <span class="number">$1</span>, %eax		<span class="comment">; 增加1</span></span><br/><span class="line">movl    %eax, -<span class="number">48</span>(%rbp) <span class="comment">; 放回数组</span></span><br/><span class="line"><span class="comment">; 我不明白的是，这里也没有什么函数调用，为什么和只制造单个变量不同，仍然分配了栈帧</span></span><br/><span class="line"><span class="comment">; 求懂的大佬解释……</span></span><br/></pre></td></tr></table></figure>
<p>好吧，编译器生成的汇编虽然很迷，但是还是可以看出：</p>
<ol>
<li>固定大小的数组是分配在栈上的（仅限自动变量）。</li>
<li>固定大小的数组真的只是一群变量，没有任何特别之处。</li>
<li>索引操作就是内存里的偏移量。</li>
</ol>
<p>现在让我们来点魔法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br/><span class="line">        <span class="keyword">int</span> arr[<span class="number">7</span>];</span><br/><span class="line">        ++arr[<span class="number">0</span>];</span><br/><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br/><span class="line">}</span><br/></pre></td></tr></table></figure>
<p>汇编这段，你会发现得到的结果和上面完全一样。</p>
<p>按照常理，难道</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">subq    <span class="number">$48</span>, %rsp</span><br/></pre></td></tr></table></figure>
<p>不应该变成:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">subq    <span class="number">$36</span>, %rsp <span class="comment">;28个字节给数组，8个给%fs:40</span></span><br/></pre></td></tr></table></figure>
<p>吗？</p>
<p>然而并不是，这是一种名曰内存对齐的骚操作：</p>
<blockquote>
<p>GCC 坚持一个X86编程指导方针，也就是一个函数使用的所有栈空间必须是16字节的整数倍。</p>
</blockquote>
<p>似乎这样我们的CPU处理起来更快，也更利于GCC优化代码……</p>
<p>所以GCC编译器另外多帮我们留了12个字节（3个<code>int</code>）的存储空间。</p>
<p>这样的话，在GCC环境下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设没有其他变量</span></span><br/><span class="line"><span class="keyword">int</span> arr[<span class="number">7</span>];</span><br/><span class="line">arr[<span class="number">7</span>] <span class="comment">//理论上来说越界，实践上来说可以</span></span><br/><span class="line">arr[<span class="number">8</span>] <span class="comment">//理论上来说越界，实践上来说还是可以 </span></span><br/><span class="line">arr[<span class="number">9</span>] <span class="comment">//理论上来说越界，实践上来说仍然可以 </span></span><br/><span class="line">arr[<span class="number">10</span>] <span class="comment">//理论上来说越界，实践上来说……这个真不行</span></span><br/></pre></td></tr></table></figure>
<p>没想到吧！</p>
<h2 id="数组的初始化"><a class="headerlink" href="#数组的初始化" title="数组的初始化"></a>数组的初始化</h2><p>汇编这段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br/><span class="line">        <span class="keyword">int</span> arr[<span class="number">10</span>]={<span class="number">0</span>};</span><br/><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br/><span class="line">}</span><br/></pre></td></tr></table></figure>
<p>得：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/></pre></td><td class="code"><pre><span class="line"><span class="comment">; 前面的代码省略了，只显示初始化部分的代码，下同</span></span><br/><span class="line"><span class="keyword">movq</span>	<span class="number">$0</span>, -<span class="number">48</span>(%rbp)</span><br/><span class="line"><span class="keyword">movq</span>	<span class="number">$0</span>, -<span class="number">40</span>(%rbp)</span><br/><span class="line"><span class="keyword">movq</span>	<span class="number">$0</span>, -<span class="number">32</span>(%rbp)</span><br/><span class="line"><span class="keyword">movq</span>	<span class="number">$0</span>, -<span class="number">24</span>(%rbp)</span><br/><span class="line"><span class="keyword">movq</span>	<span class="number">$0</span>, -<span class="number">16</span>(%rbp)</span><br/></pre></td></tr></table></figure>
<p>可见用0初始化就是全部填0，这里编译器用了一个技巧：直接用64位的0去每8个字节填充一次（感谢内存对齐，最后不会有“多出来四个字节需要单独填充”这种情况）</p>
<p>我们赋一些非0的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br/><span class="line">        <span class="keyword">int</span> arr[<span class="number">10</span>]={<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>};</span><br/><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br/><span class="line">}</span><br/></pre></td></tr></table></figure>
<p>得到</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">movq</span>	<span class="number">$0</span>, -<span class="number">48</span>(%rbp)</span><br/><span class="line"><span class="keyword">movq</span>	<span class="number">$0</span>, -<span class="number">40</span>(%rbp)</span><br/><span class="line"><span class="keyword">movq</span>	<span class="number">$0</span>, -<span class="number">32</span>(%rbp)</span><br/><span class="line"><span class="keyword">movq</span>	<span class="number">$0</span>, -<span class="number">24</span>(%rbp)</span><br/><span class="line"><span class="keyword">movq</span>	<span class="number">$0</span>, -<span class="number">16</span>(%rbp)</span><br/><span class="line">movl	<span class="number">$1</span>, -<span class="number">48</span>(%rbp)</span><br/><span class="line">movl	<span class="number">$2</span>, -<span class="number">44</span>(%rbp)</span><br/><span class="line">movl	<span class="number">$3</span>, -<span class="number">40</span>(%rbp)</span><br/></pre></td></tr></table></figure>
<p>编译器傻傻地用0全部填充了一遍，然后把前面几个改成需要的数了……</p>
<p>完全的初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br/><span class="line">        <span class="keyword">int</span> arr[<span class="number">7</span>]={<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>}; <span class="comment">//我们来看一个存在内存对齐问题的情况</span></span><br/><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br/><span class="line">}</span><br/></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/></pre></td><td class="code"><pre><span class="line">movl	$1, -48(%rbp)</span><br/><span class="line">movl	$2, -44(%rbp)</span><br/><span class="line">movl	$3, -40(%rbp)</span><br/><span class="line">movl	$4, -36(%rbp)</span><br/><span class="line">movl	$5, -32(%rbp)</span><br/><span class="line">movl	$6, -28(%rbp)</span><br/><span class="line">movl	$7, -24(%rbp)</span><br/></pre></td></tr></table></figure>
<p>可见只有在提供了所有元素的初始值的情况下才会一个个值去初始化，而在此情况下因为内存对齐而空出来的内存是不会被初始化的。</p>
<p>但是在初始化为0的情况下因为内存对齐而空出来的内存也是会被填入0的（想一想，为什么？）。</p>
<p>想要进行这样的骚操作的人：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">7</span>]={<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>}; <span class="comment">//试图填充内存对齐空出来的内存</span></span><br/></pre></td></tr></table></figure>
<p>你们还是别想了，编译的时候会检查然后报错的。</p>
<p>可能有同学想到了一个问题：初始化一个10个元素的数组为全0就使用了整整5行的汇编代码，如果初始化一个有成千上万个元素的数组……</p>
<p>好在写编译器的人不傻（实际上他们都是天才），我们试试这段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>{</span><br/><span class="line">        <span class="keyword">int</span> arr[<span class="number">20</span>]={<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>};</span><br/><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br/><span class="line">}</span><br/></pre></td></tr></table></figure>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/></pre></td><td class="code"><pre><span class="line">leaq	-<span class="number">96</span>(%rbp), %rdx <span class="comment">; 取得 -96(%rbp) 的偏移地址，放在%rdx中</span></span><br/><span class="line">movl	<span class="number">$0</span>, %eax	    <span class="comment">; eax清0</span></span><br/><span class="line">movl	<span class="number">$10</span>, %ecx		<span class="comment">; ecx表示要重复填充8字节0的次数</span></span><br/><span class="line"><span class="keyword">movq</span>	%rdx, %rdi</span><br/><span class="line"><span class="comment">; rep: 将后面的内容执行%ecx次</span></span><br/><span class="line"><span class="comment">; stosq: 将%eax处的8字节内容放入(%rdi)处，然后%rdi自增</span></span><br/><span class="line"><span class="keyword">rep</span> <span class="keyword">stosq</span>				</span><br/><span class="line"><span class="comment">; 修改提供初始化值的元素</span></span><br/><span class="line">movl	<span class="number">$1</span>, -<span class="number">96</span>(%rbp)</span><br/><span class="line">movl	<span class="number">$2</span>, -<span class="number">92</span>(%rbp)</span><br/><span class="line">movl	<span class="number">$3</span>, -<span class="number">88</span>(%rbp)</span><br/></pre></td></tr></table></figure>
<p>可见在数据量大的时候，编译器会使用类似循环的几个指令来初始化。</p>
<p>但是在提供了所有元素的初始值的情况下，还是会一个个值去初始化的……只要你敢提供成千上万个初始值，编译器就敢奉陪到底。</p>
<h2 id="变量大小的数组（VLA）"><a class="headerlink" href="#变量大小的数组（VLA）" title="变量大小的数组（VLA）"></a>变量大小的数组（VLA）</h2><p>VLA的汇编实现真的是一通骚操作（使用了各种奇葩的汇编指令，像<code>cltq</code>、<code>movslq</code>这些），然后使用的方法也和正常的数组不一样。</p>
<p>我觉得我有耐心看完的话也许是可以看懂的，但是我完全没有耐心读这么长的gas的汇编代码……</p>
<p>这里贴一下，等我有空+有心情再研究吧。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/><span class="line">26</span><br/><span class="line">27</span><br/><span class="line">28</span><br/><span class="line">29</span><br/><span class="line">30</span><br/><span class="line">31</span><br/><span class="line">32</span><br/><span class="line">33</span><br/><span class="line">34</span><br/></pre></td><td class="code"><pre><span class="line"><span class="comment">; n 在 -28(%rbp) 中</span></span><br/><span class="line"><span class="comment">; int arr[n]</span></span><br/><span class="line">movl	-<span class="number">28</span>(%rbp), %eax</span><br/><span class="line">movslq	%eax, %rdx</span><br/><span class="line">subq	<span class="number">$1</span>, %rdx</span><br/><span class="line"><span class="keyword">movq</span>	%rdx, -<span class="number">24</span>(%rbp)</span><br/><span class="line">movslq	%eax, %rdx</span><br/><span class="line"><span class="keyword">movq</span>	%rdx, %r8</span><br/><span class="line">movl	<span class="number">$0</span>, %r9d</span><br/><span class="line">movslq	%eax, %rdx</span><br/><span class="line"><span class="keyword">movq</span>	%rdx, %rsi</span><br/><span class="line">movl	<span class="number">$0</span>, %edi</span><br/><span class="line">cltq</span><br/><span class="line">salq	<span class="number">$2</span>, %rax</span><br/><span class="line">leaq	<span class="number">3</span>(%rax), %rdx</span><br/><span class="line">movl	<span class="number">$16</span>, %eax</span><br/><span class="line">subq	<span class="number">$1</span>, %rax</span><br/><span class="line">addq	%rdx, %rax</span><br/><span class="line">movl	<span class="number">$16</span>, %edi</span><br/><span class="line">movl	<span class="number">$0</span>, %edx</span><br/><span class="line">divq	%rdi</span><br/><span class="line">imulq	<span class="number">$16</span>, %rax, %rax</span><br/><span class="line">subq	%rax, %rsp</span><br/><span class="line"><span class="keyword">movq</span>	%rsp, %rax</span><br/><span class="line">addq	<span class="number">$3</span>, %rax</span><br/><span class="line">shrq	<span class="number">$2</span>, %rax</span><br/><span class="line">salq	<span class="number">$2</span>, %rax</span><br/><span class="line"><span class="keyword">movq</span>	%rax, -<span class="number">16</span>(%rbp)</span><br/><span class="line"><span class="comment">; ++arr[0]</span></span><br/><span class="line"><span class="keyword">movq</span>	-<span class="number">16</span>(%rbp), %rax</span><br/><span class="line">movl	(%rax), %eax</span><br/><span class="line">leal	<span class="number">1</span>(%rax), %edx</span><br/><span class="line"><span class="keyword">movq</span>	-<span class="number">16</span>(%rbp), %rax</span><br/><span class="line">movl	%edx, (%rax)</span><br/></pre></td></tr></table></figure>
<p>好吧，别为这些难懂的asm代码头痛了，我们看看VLA应用时候的坑:</p>
<p>首先，上面的代码明显所有操作都没有涉及堆，所以VLA是分配在栈上的，<strong>不存在内存泄漏的问题</strong>。</p>
<p>然而，由于一般来说栈空间比堆小，VLA不能开太大，如果开的太大会直接发生运行时错误，而动态分配的数组不仅可以开的更大些，而且如果开不下，还会给程序猿处理问题的机会（C中负责分配内存的函数（<code>alloc</code>一族函数）会返回一个空指针，<code>new</code>则会抛一个异常）。</p>
<p>我师傅告诉我，C++标准里从来没有VLA这一说，所以只从标准上来看，即使是最新的C++标准也并非完全兼容C。</p>
<p>我看了下，是真的：</p>
<p>C :</p>
<p><img alt="屏幕快照 2017-10-10 14.47.14" src="./屏幕快照 2017-10-10 14.47.14.png"/></p>
<p>C++:</p>
<p><img alt="屏幕快照 2017-10-10 14.47.45" src="./屏幕快照 2017-10-10 14.47.45.png"/></p>
<p>g++为了兼容C代码考虑，才会以编译器扩展的方式允许在C++代码里使用VLA的。</p>
<p>因此<strong>在C++程序中不要使用VLA</strong>！</p>
<p>个人对于不同情况下使用哪类数组的看法：</p>
<ol>
<li>如果你在用纯粹的C，并且确定自己的编译器支持C99标准（或者以 C89+编译器扩展 的方式提供了VLA的支持，就像GCC不开C99时那样），还清楚自己的数组没有大到会爆栈的地步，那么可以放心使用VLA。</li>
<li>如果你在使用纯粹的C，但是数组太大有爆栈危险，请动态分配数组。</li>
<li>如果你在使用C++，请尽量使用<code>vector</code>。</li>
<li>如果你在使用C++，因为某些原因不使用<code>vector</code>，请动态分配数组。</li>
</ol>
<p>再次重复：<strong>在C++程序中不要使用VLA</strong>！</p>

