---
title: 简单CPU的设计与实现
date: 2019-01-29 00:00:00
tags: [verilog, 计算机组成]
mathjax: true
comments: true
summary: CPU的原理装置真的不难造。
---
<p>本文假设读者会基本的verilog。</p>
    <p>本文会实现一个CPU的原理装置，作者对几乎所有内容进行了大量的简化，以便于理解，但所制作的简易CPU能完成大部分功能。</p>
<h2 id="设计思路"><a class="headerlink" href="#设计思路" title="设计思路"></a>设计思路</h2><p>传统CPU的控制往往较为复杂，有多种多样的微操作，但本文设计的CPU只有下面几种“微操作”，且一定是按照这个顺序执行，即：</p>
<ul>
<li>根据PC寄存器的值直接从指令Cache取出指令并利用<strong>组合逻辑</strong>进行译码<sup><a href="#fn_1" id="reffn_1">1</a></sup></li>
<li>将1到2个数据从某处连入ALU</li>
<li>将ALU运算结果输出到某处</li>
</ul>
<p>即：</p>
<p><img alt="design" src="./design.svg"/></p>
<p>用这个方式实现的CPU仍然有所有必须的功能，且非常容易理解。</p>
<h2 id="最简单的计算"><a class="headerlink" href="#最简单的计算" title="最简单的计算"></a>最简单的计算</h2><p>CPU能做的事情无非是计算和控制，其中计算比较容易实现。</p>
<p>CPU中主要的计算部件，学过计组的人都知道，是ALU。</p>
<p>ALU 不过是一个简单的组合逻辑电路，实现如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ALU(</span><br/><span class="line">  <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] input1,                <span class="comment">// 操作数1</span></span><br/><span class="line">  <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] input2,                <span class="comment">// 操作数2</span></span><br/><span class="line">  <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">2</span>:<span class="number">0</span>] func,                  <span class="comment">// 功能选择</span></span><br/><span class="line">  <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] result = <span class="number">8'b00000000</span>   <span class="comment">// 结果</span></span><br/><span class="line">);</span><br/><span class="line">    <span class="keyword">parameter</span> ADD  = <span class="number">3'b000</span>,</span><br/><span class="line">              SUB  = <span class="number">3'b001</span>,</span><br/><span class="line">              OR   = <span class="number">3'b010</span>,</span><br/><span class="line">              AND  = <span class="number">3'b011</span>,</span><br/><span class="line">    		  <span class="comment">// 100和101保留</span></span><br/><span class="line">              NOT  = <span class="number">3'b110</span>,</span><br/><span class="line">              HLT  = <span class="number">3'b111</span>;</span><br/><span class="line">    <span class="keyword">always</span> @(input1 <span class="keyword">or</span> input2 <span class="keyword">or</span> func) <span class="keyword">begin</span></span><br/><span class="line">      <span class="keyword">case</span>(func)</span><br/><span class="line">        ADD : result = input1 + input2;</span><br/><span class="line">        SUB : result = input1 - input2;</span><br/><span class="line">        OR  : result = input1 | input2;</span><br/><span class="line">        AND : result = input1 &amp; input2;</span><br/><span class="line">        NOT : result = ~input1;</span><br/><span class="line">        HLT : result = input1;</span><br/><span class="line">      <span class="keyword">endcase</span></span><br/><span class="line">    <span class="keyword">end</span></span><br/><span class="line"><span class="keyword">endmodule</span></span><br/></pre></td></tr></table></figure>
<h2 id="寄存器堆"><a class="headerlink" href="#寄存器堆" title="寄存器堆"></a>寄存器堆</h2><p>要计算，当然要有用来计算的数据，还要存放运算结果的地方。</p>
<p>一般来说大部分计算数据的来源和运输结果的去向都是寄存器。</p>
<p>很多计算都有两个输入和一个输出，所以我们的寄存器堆要有两组输出，每组输出由(输出寄存器编号,输出数据线)和一组输入(输入寄存器编号,输入数据线)。</p>
<p>相应verilog代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/><span class="line">26</span><br/><span class="line">27</span><br/><span class="line">28</span><br/><span class="line">29</span><br/><span class="line">30</span><br/><span class="line">31</span><br/><span class="line">32</span><br/><span class="line">33</span><br/><span class="line">34</span><br/><span class="line">35</span><br/><span class="line">36</span><br/><span class="line">37</span><br/><span class="line">38</span><br/><span class="line">39</span><br/><span class="line">40</span><br/><span class="line">41</span><br/><span class="line">42</span><br/><span class="line">43</span><br/><span class="line">44</span><br/><span class="line">45</span><br/><span class="line">46</span><br/><span class="line">47</span><br/><span class="line">48</span><br/><span class="line">49</span><br/><span class="line">50</span><br/><span class="line">51</span><br/><span class="line">52</span><br/><span class="line">53</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> RegisterFile(</span><br/><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> read_clk,            <span class="comment">// 此时钟信号上升沿时从寄存器中读取</span></span><br/><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> write_clk,           <span class="comment">// 此时钟信号上升沿时向寄存器中写入</span></span><br/><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">2</span>:<span class="number">0</span>] read_address1, <span class="comment">// 要读取的地址1</span></span><br/><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">2</span>:<span class="number">0</span>] read_address2, <span class="comment">// 要读取的地址2</span></span><br/><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] out_1,         <span class="comment">// 读取的输出</span></span><br/><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] out_2,         <span class="comment">// 读取的输入</span></span><br/><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">2</span>:<span class="number">0</span>] write_address, <span class="comment">// 要写入的地址</span></span><br/><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] in,            <span class="comment">// 要写入的值</span></span><br/><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> in_en                <span class="comment">// 写入使能</span></span><br/><span class="line">);</span><br/><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] data [<span class="number">7</span>:<span class="number">0</span>];           <span class="comment">// 寄存器们</span></span><br/><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] reg0;</span><br/><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] reg1;</span><br/><span class="line">    <span class="keyword">assign</span> reg0 = data[<span class="number">0</span>];</span><br/><span class="line">    <span class="keyword">assign</span> reg1 = data[<span class="number">1</span>];</span><br/><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> read_clk) <span class="keyword">begin</span></span><br/><span class="line">        <span class="keyword">case</span> (read_address1)</span><br/><span class="line">          <span class="number">'h0</span>: out_1 &lt;= data[<span class="number">0</span>];</span><br/><span class="line">          <span class="number">'h1</span>: out_1 &lt;= data[<span class="number">1</span>];</span><br/><span class="line">          <span class="number">'h2</span>: out_1 &lt;= data[<span class="number">2</span>];</span><br/><span class="line">          <span class="number">'h3</span>: out_1 &lt;= data[<span class="number">3</span>];</span><br/><span class="line">          <span class="number">'h4</span>: out_1 &lt;= data[<span class="number">4</span>];</span><br/><span class="line">          <span class="number">'h5</span>: out_1 &lt;= data[<span class="number">5</span>];</span><br/><span class="line">          <span class="number">'h6</span>: out_1 &lt;= data[<span class="number">6</span>];</span><br/><span class="line">          <span class="number">'h7</span>: out_1 &lt;= data[<span class="number">7</span>];</span><br/><span class="line">        <span class="keyword">endcase</span></span><br/><span class="line">        <span class="keyword">case</span> (read_address2)</span><br/><span class="line">          <span class="number">'h0</span>: out_2 &lt;= data[<span class="number">0</span>];</span><br/><span class="line">          <span class="number">'h1</span>: out_2 &lt;= data[<span class="number">1</span>];</span><br/><span class="line">          <span class="number">'h2</span>: out_2 &lt;= data[<span class="number">2</span>];</span><br/><span class="line">          <span class="number">'h3</span>: out_2 &lt;= data[<span class="number">3</span>];</span><br/><span class="line">          <span class="number">'h4</span>: out_2 &lt;= data[<span class="number">4</span>];</span><br/><span class="line">          <span class="number">'h5</span>: out_2 &lt;= data[<span class="number">5</span>];</span><br/><span class="line">          <span class="number">'h6</span>: out_2 &lt;= data[<span class="number">6</span>];</span><br/><span class="line">          <span class="number">'h7</span>: out_2 &lt;= data[<span class="number">7</span>];</span><br/><span class="line">        <span class="keyword">endcase</span></span><br/><span class="line">    <span class="keyword">end</span></span><br/><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> write_clk) <span class="keyword">begin</span></span><br/><span class="line">        <span class="keyword">if</span> (in_en) <span class="keyword">begin</span></span><br/><span class="line">            <span class="keyword">case</span>(write_address)</span><br/><span class="line">                <span class="number">'h0</span>: data[<span class="number">0</span>] &lt;= in;</span><br/><span class="line">                <span class="number">'h1</span>: data[<span class="number">1</span>] &lt;= in;</span><br/><span class="line">                <span class="number">'h2</span>: data[<span class="number">2</span>] &lt;= in;</span><br/><span class="line">                <span class="number">'h3</span>: data[<span class="number">3</span>] &lt;= in;</span><br/><span class="line">                <span class="number">'h4</span>: data[<span class="number">4</span>] &lt;= in;</span><br/><span class="line">                <span class="number">'h5</span>: data[<span class="number">5</span>] &lt;= in;</span><br/><span class="line">                <span class="number">'h6</span>: data[<span class="number">6</span>] &lt;= in;</span><br/><span class="line">                <span class="number">'h7</span>: data[<span class="number">7</span>] &lt;= in;</span><br/><span class="line">            <span class="keyword">endcase</span></span><br/><span class="line">        <span class="keyword">end</span></span><br/><span class="line">    <span class="keyword">end</span></span><br/><span class="line"><span class="keyword">endmodule</span></span><br/></pre></td></tr></table></figure>
<h2 id="最简单的控制与指令系统"><a class="headerlink" href="#最简单的控制与指令系统" title="最简单的控制与指令系统"></a>最简单的控制与指令系统</h2><p>我们来设计一个简单到不能再简单的指令系统：</p>
<h3 id="指令格式"><a class="headerlink" href="#指令格式" title="指令格式"></a>指令格式</h3><p><img alt="instruction" src="./instruction.png"/></p>
<p>（你可能已经看出来了，寄存器到寄存器的MOV其实就是“运算为不运算”的运算指令）</p>
<h3 id="程序计数器"><a class="headerlink" href="#程序计数器" title="程序计数器"></a>程序计数器</h3><p>为了方便起见，我们暂时不和RAM/ROM或是FLASH进行对接，而是手动实现一个简单的ROM，将程序代码放在里面：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ROM(</span><br/><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] read_address,</span><br/><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] result</span><br/><span class="line">);</span><br/><span class="line">    <span class="keyword">always</span> @(read_address) <span class="keyword">begin</span></span><br/><span class="line">        <span class="keyword">case</span> (read_address)</span><br/><span class="line">            <span class="number">'h00</span>: result &lt;= <span class="number">'h1111</span>;			<span class="comment">// 留空</span></span><br/><span class="line">            <span class="number">'h01</span>: result &lt;= <span class="number">'hB833</span>;     <span class="comment">// R0 = 33</span></span><br/><span class="line">            <span class="number">'h02</span>: result &lt;= <span class="number">'hB911</span>;     <span class="comment">// R1 = 11</span></span><br/><span class="line">            <span class="number">'h03</span>: result &lt;= <span class="number">'h0004</span>;     <span class="comment">// R0 = R0 + R1</span></span><br/><span class="line">		    		<span class="number">'h04</span>: result &lt;= <span class="number">'hF803</span>;     <span class="comment">// JMP 03</span></span><br/><span class="line">        <span class="keyword">endcase</span></span><br/><span class="line">    <span class="keyword">end</span></span><br/><span class="line"><span class="keyword">endmodule</span></span><br/></pre></td></tr></table></figure>
<p>而程序计数器就只不过是一个普通的<code>reg [7:0]</code>，放入<code>read_address</code>就能得到要执行的指令。</p>
<h3 id="译码与执行"><a class="headerlink" href="#译码与执行" title="译码与执行"></a>译码与执行</h3><p>在执行时我们要把一条指令的执行过程分为三步：</p>
<ol>
<li>计算下一个PC值，同时获得要执行的指令。</li>
<li>对指令进行译码，若有必要的话从寄存器堆中选中操作数对应的寄存器</li>
<li>将结果写回寄存器堆</li>
</ol>
<p>那么我们可以做出这样的实现：</p>
<p>首先是构造一个三分频的时钟信号，用于驱动上面三步：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Clock(</span><br/><span class="line">  <span class="keyword">input</span> <span class="keyword">wire</span> global_clk,</span><br/><span class="line">  <span class="keyword">output</span> <span class="keyword">wire</span> [<span class="number">2</span>:<span class="number">0</span>] generated_clks</span><br/><span class="line">);</span><br/><span class="line">  <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] clk_reg = <span class="number">'b100</span>;</span><br/><span class="line">  <span class="keyword">always</span> @(<span class="keyword">posedge</span> global_clk) <span class="keyword">begin</span></span><br/><span class="line">    {clk_reg[<span class="number">0</span>],clk_reg} = clk_reg &lt;&lt; <span class="number">1</span>;</span><br/><span class="line">  <span class="keyword">end</span></span><br/><span class="line">  <span class="keyword">assign</span> generated_clks = clk_reg;</span><br/><span class="line"><span class="keyword">endmodule</span></span><br/></pre></td></tr></table></figure>
<p>然后是CPU的顶层接口：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/><span class="line">21</span><br/><span class="line">22</span><br/><span class="line">23</span><br/><span class="line">24</span><br/><span class="line">25</span><br/><span class="line">26</span><br/><span class="line">27</span><br/><span class="line">28</span><br/><span class="line">29</span><br/><span class="line">30</span><br/><span class="line">31</span><br/><span class="line">32</span><br/><span class="line">33</span><br/><span class="line">34</span><br/><span class="line">35</span><br/><span class="line">36</span><br/><span class="line">37</span><br/><span class="line">38</span><br/><span class="line">39</span><br/><span class="line">40</span><br/><span class="line">41</span><br/><span class="line">42</span><br/><span class="line">43</span><br/><span class="line">44</span><br/><span class="line">45</span><br/><span class="line">46</span><br/><span class="line">47</span><br/><span class="line">48</span><br/><span class="line">49</span><br/><span class="line">50</span><br/><span class="line">51</span><br/><span class="line">52</span><br/><span class="line">53</span><br/><span class="line">54</span><br/><span class="line">55</span><br/></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">include</span> "alu.v"</span></span><br/><span class="line"><span class="meta">`<span class="meta-keyword">include</span> "clock.v"</span></span><br/><span class="line"><span class="meta">`<span class="meta-keyword">include</span> "ROM.v"</span></span><br/><span class="line"><span class="meta">`<span class="meta-keyword">include</span> "register_file.v"</span></span><br/><span class="line"><span class="keyword">module</span> CPU(</span><br/><span class="line">    <span class="keyword">input</span> <span class="keyword">wire</span> clk</span><br/><span class="line">);</span><br/><span class="line">    <span class="keyword">wire</span> next_pc_clk;</span><br/><span class="line">    <span class="keyword">wire</span> fetch_data_clk;</span><br/><span class="line">    <span class="keyword">wire</span> write_back_clk;</span><br/><span class="line">    <span class="comment">// 分频时钟</span></span><br/><span class="line">    Clock clock(clk,{write_back_clk,fetch_data_clk,next_pc_clk});</span><br/><span class="line">    <span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] program_counter = <span class="number">0</span>;	</span><br/><span class="line">    <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] instruction_register;</span><br/><span class="line">    ROM instruction_rom(program_counter,instruction_register);</span><br/><span class="line">    <span class="comment">// 操作数是立即数还是寄存器</span></span><br/><span class="line">    <span class="keyword">wire</span> imm_or_register;</span><br/><span class="line">    <span class="comment">// 是否是跳转</span></span><br/><span class="line">    <span class="keyword">wire</span> jmp;</span><br/><span class="line">    <span class="comment">// ALU操作</span></span><br/><span class="line">    <span class="keyword">wire</span> [<span class="number">2</span>:<span class="number">0</span>] alu_op;</span><br/><span class="line"> 	<span class="comment">// 选中输入/输出的寄存器编号</span></span><br/><span class="line">    <span class="keyword">wire</span> [<span class="number">2</span>:<span class="number">0</span>] out_reg;</span><br/><span class="line">    <span class="keyword">wire</span> [<span class="number">2</span>:<span class="number">0</span>] in_reg1;</span><br/><span class="line">    <span class="keyword">wire</span> [<span class="number">2</span>:<span class="number">0</span>] in_reg2;</span><br/><span class="line">    <span class="comment">// 立即数</span></span><br/><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] imm;</span><br/><span class="line">    <span class="keyword">wire</span> [<span class="number">1</span>:<span class="number">0</span>] <span class="number">_</span>;</span><br/><span class="line">    <span class="comment">// 译码</span></span><br/><span class="line">    <span class="keyword">assign</span> {imm_or_register,jmp,alu_op,out_reg,in_reg2,in_reg1,<span class="number">_</span>} = instruction_register;</span><br/><span class="line">    <span class="keyword">assign</span> imm = instruction_register[<span class="number">7</span>:<span class="number">0</span>];</span><br/><span class="line">    <span class="comment">// 寄存器堆的输出</span></span><br/><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] out_1;</span><br/><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] out_2;</span><br/><span class="line">    <span class="comment">// 寄存器堆的输入</span></span><br/><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] in;</span><br/><span class="line">   	<span class="comment">// 寄存器堆是否接受输入</span></span><br/><span class="line">    <span class="keyword">wire</span> in_en;</span><br/><span class="line">    </span><br/><span class="line">    <span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] op1;</span><br/><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> next_pc_clk) <span class="keyword">begin</span></span><br/><span class="line">        <span class="comment">// PC+1</span></span><br/><span class="line">        program_counter &lt;= program_counter + <span class="number">1</span>;</span><br/><span class="line">        <span class="keyword">if</span> (jmp) <span class="keyword">begin</span></span><br/><span class="line">            <span class="comment">// 跳转</span></span><br/><span class="line">            program_counter &lt;= imm;</span><br/><span class="line">        <span class="keyword">end</span></span><br/><span class="line">    <span class="keyword">end</span></span><br/><span class="line">    <span class="comment">// 跳转时，寄存器堆不接受输入</span></span><br/><span class="line">    <span class="keyword">assign</span> in_en = jmp?<span class="number">0</span>:<span class="number">1</span>;</span><br/><span class="line">    RegisterFile register_file(fetch_data_clk,write_back_clk,in_reg1,in_reg2,out_1,out_2,out_reg,in,in_en);</span><br/><span class="line">    <span class="comment">// 第一个操作数根据译码得到的 操作数是立即数还是寄存器 的值，选择使用立即数还是寄存器堆输出1</span></span><br/><span class="line">    <span class="keyword">assign</span> op1 = imm_or_register ? imm : out_1;</span><br/><span class="line">    ALU alu(op1,out_2,alu_op,in);</span><br/><span class="line"><span class="keyword">endmodule</span></span><br/></pre></td></tr></table></figure>
<p>这样一来这个CPU就能跑了。</p>
<h2 id="Futher-work"><a class="headerlink" href="#Futher-work" title="Futher work"></a>Futher work</h2><ol>
<li>和内存对接</li>
<li>流水线</li>
</ol>
<blockquote id="fn_1">
<sup>1</sup>. 因此甚至不需要一个IR寄存器。<a href="#reffn_1" title="Jump back to footnote [1] in the text."> ↩</a>
</blockquote>

