---
title: 结构体
date: 2017-10-17 00:00:00
tags: [C, C++, 汇编]
mathjax: true
comments: true
summary: C语言中的结构体本质上究竟是什么？
---
<h1 id="结构体"><a class="headerlink" href="#结构体" title="结构体"></a>结构体</h1><p>（上课讲结构体的大小完全不考虑内存对齐也是醉了……）</p>
 hexo-inject:begin  hexo-inject:end <p>（况且结构体的内存对齐还不是编译器的magic，而是官方文档中有说明的东西）</p>
<p>好吧，让我们来看看结构体，当然，仍然是from the perspective of asm。</p>
<p>（注意！除特殊说明外，以下内容中的结构体均指C语言中正儿八经的结构体，对于C结构体、C++结构体和C++类的关系，我们将在最后一部分说明）</p>
<h2 id="Basic-things"><a class="headerlink" href="#Basic-things" title="Basic things"></a>Basic things</h2><p>汇编这一段</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> {</span></span><br/><span class="line">	<span class="keyword">int</span> a;</span><br/><span class="line">	<span class="keyword">int</span> b;</span><br/><span class="line">	<span class="keyword">int</span> c;</span><br/><span class="line">};</span><br/><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br/><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">S</span> <span class="title">s</span>;</span></span><br/><span class="line">	s.a = <span class="number">1</span>;	<span class="comment">// 使用一下变量，避免被“优化”掉</span></span><br/><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br/><span class="line">}</span><br/></pre></td></tr></table></figure>
<p>结果和结构体相关的代码只有这一段：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">movl	<span class="number">$1</span>, -<span class="number">16</span>(%rbp) <span class="comment">; s.a = 1</span></span><br/></pre></td></tr></table></figure>
<p>可见结构体其实就是连续制作一大堆变量……</p>
<p>虽然大部分类型的汇编都提供了.struct等伪指令，但编译器似乎认为只有弱鸡的人类才需要用那种东西，对于强大的编译器来说，直接分配内存就够了。</p>
<p>结构体变量的赋值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> {</span></span><br/><span class="line">        <span class="keyword">int</span> a;</span><br/><span class="line">        <span class="keyword">int</span> b;</span><br/><span class="line">        <span class="keyword">int</span> c;</span><br/><span class="line">};</span><br/><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br/><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">S</span> <span class="title">s1</span>,<span class="title">s2</span>;</span></span><br/><span class="line">        s1.a = <span class="number">1</span>;</span><br/><span class="line">        s2 = s1;</span><br/><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br/><span class="line">}</span><br/></pre></td></tr></table></figure>
<p>同样没什么特别的</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/></pre></td><td class="code"><pre><span class="line">movl	<span class="number">$1</span>, -<span class="number">32</span>(%rbp)</span><br/><span class="line"><span class="comment">; 先移动八字节</span></span><br/><span class="line"><span class="keyword">movq</span>	-<span class="number">32</span>(%rbp), %rax</span><br/><span class="line"><span class="keyword">movq</span>	%rax, -<span class="number">16</span>(%rbp)</span><br/><span class="line"><span class="comment">; 再移动四字节</span></span><br/><span class="line">movl	-<span class="number">24</span>(%rbp), %eax</span><br/><span class="line">movl	%eax, -<span class="number">8</span>(%rbp)</span><br/></pre></td></tr></table></figure>
<h2 id="内存对齐"><a class="headerlink" href="#内存对齐" title="内存对齐"></a>内存对齐</h2><p>显然上面那个结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> {</span></span><br/><span class="line">        <span class="keyword">int</span> a;</span><br/><span class="line">        <span class="keyword">int</span> b;</span><br/><span class="line">        <span class="keyword">int</span> c;</span><br/><span class="line">};</span><br/></pre></td></tr></table></figure>
<p>的变量的大小为12字节（4+4+4），这很好理解。</p>
<p>然而</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> {</span></span><br/><span class="line">        <span class="keyword">char</span> a;</span><br/><span class="line">        <span class="keyword">int</span> b;</span><br/><span class="line">        <span class="keyword">double</span> c;</span><br/><span class="line">};</span><br/></pre></td></tr></table></figure>
<p>的大小是多少？</p>
<p>是 1+4+8 = 13 吗？借助sizeof看看，我们就会发现并非13，而是16。</p>
<p><strong>一个结构体变量在内存中占用的存储空间并不等于其元素的宽度之和！</strong></p>
<p>我们深入内部看一下这些成员变量是怎么分布的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> {</span></span><br/><span class="line">        <span class="keyword">char</span> a;</span><br/><span class="line">        <span class="keyword">int</span> b;</span><br/><span class="line">        <span class="keyword">double</span> c;</span><br/><span class="line">};</span><br/><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br/><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">S</span> <span class="title">s</span>;</span></span><br/><span class="line">        s.a = <span class="string">'a'</span>;</span><br/><span class="line">        s.b = <span class="number">1</span>;</span><br/><span class="line">        s.c = <span class="number">2.5</span>;</span><br/><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br/><span class="line">}</span><br/></pre></td></tr></table></figure>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/></pre></td><td class="code"><pre><span class="line"><span class="comment">; 注意此处浮点数的处理方法跟编译环境相关</span></span><br/><span class="line"><span class="comment">; 在我的环境下，gcc默认开启了sse指令集来进行浮点处理</span></span><br/><span class="line"><span class="comment">; 这让代码变得更为复杂</span></span><br/><span class="line"><span class="comment">; 此处贴出手动关闭sse（-mno-sse）的代码</span></span><br/><span class="line">movb	<span class="number">$97</span>, -<span class="number">16</span>(%rbp)</span><br/><span class="line">movl	<span class="number">$1</span>, -<span class="number">12</span>(%rbp)</span><br/><span class="line">fldl	.LC0(%rip)		<span class="comment">; 将.LC0代表的浮点数压入浮点协处理器堆栈</span></span><br/><span class="line">fstpl	-<span class="number">8</span>(%rbp)		<span class="comment">; 将协处理器栈顶数据送到-8(%rbp)位置</span></span><br/><span class="line"><span class="comment">; 省略无关代码</span></span><br/><span class="line"></span><br/><span class="line"><span class="comment">; 本次不着重讲解浮点数储存原理</span></span><br/><span class="line"><span class="comment">; 或许我会另外写文章</span></span><br/><span class="line"><span class="symbol">.LC0:</span></span><br/><span class="line"><span class="meta">	.long</span>	<span class="number">0</span></span><br/><span class="line"><span class="meta">	.long</span>	<span class="number">1074003968</span></span><br/><span class="line"><span class="comment">; 省略无关代码</span></span><br/></pre></td></tr></table></figure>
<p>看了上面的代码，我们可以描绘出这样的内存分布图：</p>
<p><img alt="memory" src="./memory.svg"/></p>
<p>显然1~3（-15(%rbp)~-13(%rbp)）这段内存被空出来了，这是为什么呢？</p>
<p>还记得我们上次说数组中提到的内存对齐吗？编译器为了处理数据的方便和快速，会分配一些并不会用到的内存。</p>
<p>而在结构体中也存在这个问题（而且与数组的优化是编译器“偷偷摸摸”进行的不同，结构体的这种空出空间的做法已经得到了标准的认可）。</p>
<p>结构体在内存中占用多少空间的正确计算方式：</p>
<ol>
<li>从结构体存储的首地址开始，每一个元素按照定义时的顺序放置到内存中，放置的位置一定会在自己宽度的整数倍上开始。（例如，以结构体首地址为0开始计算，4字节的int变量一定会放在0、4、8、12 ……这些位置上，8字节的浮点变量一定会放在0、8、16、24 …… 这些位置上）</li>
<li>所有元素放入后，检查所用的存储单元宽度是否为所有元素中最宽的元素的宽度的整数倍，若不是，则补齐为它的整数倍。（例如一个各元素宽度按顺序为8，4，1的结构体，在放入所有元素后大小为13，需要补齐到8的整数倍，故最终结构体大小为16）</li>
</ol>
<p>了解了这两条规则，大部分结构体大小的计算就难不倒我们了，但是还有一个“恐怖的大怪兽”：结构体中的数组，我们知道数组是有内存对齐这个操作的，那么在已经进行内存对齐的数组上再次进行结构体的内存对齐，究竟会发生什么呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> {</span></span><br/><span class="line">        <span class="keyword">int</span> a[<span class="number">7</span>];</span><br/><span class="line">        <span class="keyword">char</span> b;</span><br/><span class="line">        <span class="keyword">double</span> c;</span><br/><span class="line">};</span><br/><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br/><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">S</span> <span class="title">s</span>;</span></span><br/><span class="line">        s.a[<span class="number">0</span>] = <span class="number">0</span>;</span><br/><span class="line">        s.b = <span class="string">'a'</span>;</span><br/><span class="line">        s.c = <span class="number">-2.5</span>;</span><br/><span class="line">        <span class="keyword">size_t</span> sz = <span class="keyword">sizeof</span>(s);</span><br/><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br/><span class="line">}</span><br/></pre></td></tr></table></figure>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/><span class="line">14</span><br/><span class="line">15</span><br/><span class="line">16</span><br/><span class="line">17</span><br/><span class="line">18</span><br/><span class="line">19</span><br/><span class="line">20</span><br/></pre></td><td class="code"><pre><span class="line"><span class="comment">; 套路</span></span><br/><span class="line"><span class="comment">; 栈上开64个字节的空间</span></span><br/><span class="line">subq	<span class="number">$64</span>, %rsp</span><br/><span class="line"><span class="keyword">movq</span>	%fs:<span class="number">40</span>, %rax</span><br/><span class="line"><span class="keyword">movq</span>	%rax, -<span class="number">8</span>(%rbp)</span><br/><span class="line">xorl	%eax, %eax</span><br/><span class="line"></span><br/><span class="line">movl	<span class="number">$0</span>, -<span class="number">48</span>(%rbp) <span class="comment">; s.a[0] = 0 s.a占用-48(%rbp)～-21(%rbp)共计28个字节</span></span><br/><span class="line">movb	<span class="number">$97</span>, -<span class="number">20</span>(%rbp)<span class="comment">; s.b = 97</span></span><br/><span class="line"><span class="comment">; s.b占用1个字节</span></span><br/><span class="line"><span class="comment">; 下面要放入一个double，故空出3个字节对齐到-16(%rbp)</span></span><br/><span class="line">fldl	.LC0(%rip)</span><br/><span class="line">fstpl	-<span class="number">16</span>(%rbp)	<span class="comment">; 8字节的一个double</span></span><br/><span class="line"><span class="keyword">movq</span>	<span class="number">$40</span>, -<span class="number">56</span>(%rbp)</span><br/><span class="line"><span class="comment">; 40 = 28 + 1 + (3) + 8</span></span><br/><span class="line"><span class="comment">; 栈空间：</span></span><br/><span class="line"><span class="comment">; -56(%rbp)~-49(%rbp) - sz 		8字节</span></span><br/><span class="line"><span class="comment">; -48(%rbp)~-9(%rbp)  - s  		40字节</span></span><br/><span class="line"><span class="comment">; -8(%rbp)~-1(%rbp)   - %fs:40	8字节</span></span><br/><span class="line"><span class="comment">; 共使用了56字节，栈空间对齐又空出了8字节</span></span><br/></pre></td></tr></table></figure>
<p>可见数组并没有对齐，想想也好理解，我们再看一次这句话：</p>
<blockquote>
<p>GCC 坚持一个X86编程指导方针，也就是一个函数使用的所有<strong>栈空间</strong>必须是16字节的整数倍。</p>
</blockquote>
<p>这句话强调的是栈空间的对齐，而非数组本身，数组的对齐只是栈空间对齐的一个特例。</p>
<p>这完全符合我们上面实验的结果。</p>
<p>我们再看一个同时使用结构体和数组时看起来非常糟糕的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> {</span></span><br/><span class="line">        <span class="keyword">char</span> b;</span><br/><span class="line">        <span class="keyword">int</span> a[<span class="number">100</span>];</span><br/><span class="line">};</span><br/></pre></td></tr></table></figure>
<p>你觉得b之后会不会对齐399个字节？</p>
<p>答案是不会，编译器没那么傻，数组在对齐的时候，b后面只空了3个字节。</p>
<p>如果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> {</span></span><br/><span class="line">        <span class="keyword">char</span> b;</span><br/><span class="line">        <span class="keyword">double</span> a[<span class="number">100</span>];</span><br/><span class="line">};</span><br/></pre></td></tr></table></figure>
<p>那么b之后空的是7个字节。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> {</span></span><br/><span class="line">        <span class="keyword">char</span> b;</span><br/><span class="line">  		<span class="keyword">int</span> c[<span class="number">10</span>];</span><br/><span class="line">        <span class="keyword">double</span> a[<span class="number">100</span>];</span><br/><span class="line">};</span><br/></pre></td></tr></table></figure>
<p>b后空3个，这种行为似乎可以理解为编译器把b之后的数组向前多开了一个元素的位置，然后向这个元素的前一个字节放入b，后几个字节留空。</p>
<p><strong>数组（包括字符串）不以常规的方式加入内存对齐的计算，而是以“向前扩展”的特别方式计算。</strong></p>
<p><strong>嵌套结构体会加入内存对齐的计算（请自己实验）。</strong></p>
<h2 id="Is-a-struct-really-a-struct"><a class="headerlink" href="#Is-a-struct-really-a-struct" title="Is a struct really a struct?"></a>Is a struct really a struct?</h2><p>Or, is a class really a class?</p>
<p>前面的结构体是纯粹的C结构体，但是在C++中，struct却可以理解为特别的class。</p>
<p>在C++中，如果你用C语言中的使用方法去使用struct，那生成的汇编和C语言生成对应的汇编毫无差别。</p>
<p>但是这可是C++，如果你往struct中添加一个成员函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> {</span></span><br/><span class="line">        <span class="keyword">int</span> a;</span><br/><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">add_a</span><span class="params">()</span> </span>{</span><br/><span class="line">                ++a;</span><br/><span class="line">        }</span><br/><span class="line">};</span><br/><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br/><span class="line">        S s;</span><br/><span class="line">        s.a = <span class="number">1</span>;</span><br/><span class="line">        s.add_a();</span><br/><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br/><span class="line">}</span><br/></pre></td></tr></table></figure>
<p>那它生成的汇编就和：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br/><span class="line">2</span><br/><span class="line">3</span><br/><span class="line">4</span><br/><span class="line">5</span><br/><span class="line">6</span><br/><span class="line">7</span><br/><span class="line">8</span><br/><span class="line">9</span><br/><span class="line">10</span><br/><span class="line">11</span><br/><span class="line">12</span><br/><span class="line">13</span><br/></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> {</span></span><br/><span class="line">	<span class="keyword">public</span>:</span><br/><span class="line">        <span class="keyword">int</span> a;</span><br/><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">add_a</span><span class="params">()</span> </span>{</span><br/><span class="line">                ++a;</span><br/><span class="line">        }</span><br/><span class="line">};</span><br/><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>{</span><br/><span class="line">        S s;</span><br/><span class="line">        s.a = <span class="number">1</span>;</span><br/><span class="line">        s.add_a();</span><br/><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br/><span class="line">}</span><br/></pre></td></tr></table></figure>
<p>生成的汇编一样了。</p>
<p>看起来，struct就是默认数据访问控制是public的class。</p>
<p>确实他们很像，而且struct就像class那样有继承有多态。</p>
<p>但是他们还是有区别的：</p>
<ol>
<li>在继承的时候，struct和class默认的继承访问权限也有区别，struct默认公有继承，而class默认私有继承。</li>
<li>class关键字在定义模版的时候可以用来替代typename，而struct并不行。</li>
</ol>
<p>其实还有个有趣的地方，我们知道struct是可以用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br/></pre></td><td class="code"><pre><span class="line">S s = {<span class="comment">/*各个成员变量的值*/</span>};</span><br/></pre></td></tr></table></figure>
<p>来赋初始值的，前面也说过，struct和访问控制全为public的class很像，那么：</p>
<p><strong>全为public的class也可以用类似的方法赋初值！</strong></p>
<p>不过这也是有条件的，似乎要求那个被赋初值的struct或class没有虚函数，没有构造函数等等。</p>
<p>有兴趣可以去试试看，也许能想到什么有趣的玩法。 </p>

